name: Deploy to AWS

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
      skip_security_scan:
        description: 'Skip security scan (emergency deployments only)'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: client-timesheet-app

jobs:
  security-scan:
    name: Run Security Scans
    if: ${{ github.event.inputs.skip_security_scan != 'true' }}
    uses: ./.github/workflows/security-scan.yml
    permissions:
      contents: read
      security-events: write
      actions: read

  build-and-push:
    name: Build and Push Docker Image
    needs: [security-scan]
    if: always() && (needs.security-scan.result == 'success' || needs.security-scan.result == 'skipped')
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    
    outputs:
      image_tag: ${{ steps.build.outputs.image_tag }}
      image_digest: ${{ steps.build.outputs.image_digest }}
      ecr_registry: ${{ steps.login-ecr.outputs.registry }}

    steps:
      - name: Checkout application repo
        uses: actions/checkout@v4

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: github-actions-deploy
          aws-region: ${{ env.AWS_REGION }}
        continue-on-error: true
        id: oidc-auth

      - name: Configure AWS credentials (fallback to access keys)
        if: steps.oidc-auth.outcome == 'failure'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build Docker image
        id: build
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -f docker/Dockerfile -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "full_image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Scan Docker image for vulnerabilities (Trivy)
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: '${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ github.sha }}'
          format: 'sarif'
          output: 'container-scan-results.sarif'
          severity: 'CRITICAL,HIGH'
          ignore-unfixed: true
          trivyignores: '.trivyignore'

      - name: Upload container scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'container-scan-results.sarif'
          category: 'container-scanning'

      - name: Check for CRITICAL vulnerabilities in container
        id: vuln-check
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "Scanning for CRITICAL vulnerabilities..."
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            aquasec/trivy:latest image \
            --severity CRITICAL \
            --exit-code 1 \
            --no-progress \
            --ignore-unfixed \
            $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG || {
              echo "CRITICAL vulnerabilities found! Blocking deployment."
              echo "critical_found=true" >> $GITHUB_OUTPUT
              exit 1
            }
          echo "critical_found=false" >> $GITHUB_OUTPUT
          echo "No CRITICAL vulnerabilities found."

      - name: Display container scan results (Table)
        if: always()
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            aquasec/trivy:latest image \
            --severity CRITICAL,HIGH,MEDIUM \
            --no-progress \
            $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG || true

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.4.0

      - name: Sign container image with Cosign
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
          COSIGN_EXPERIMENTAL: "true"
        run: |
          IMAGE_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG 2>/dev/null || echo "")
          if [ -n "$IMAGE_DIGEST" ]; then
            echo "Signing image: $IMAGE_DIGEST"
            cosign sign --yes $IMAGE_DIGEST || echo "Image signing skipped (keyless signing requires OIDC)"
          else
            echo "Image digest not available, pushing first..."
          fi

      - name: Push image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          IMAGE_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG)
          echo "image_digest=$IMAGE_DIGEST" >> $GITHUB_OUTPUT

      - name: Sign pushed image with Cosign
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
          COSIGN_EXPERIMENTAL: "true"
        run: |
          IMAGE_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG)
          if [ -n "$IMAGE_DIGEST" ]; then
            echo "Signing pushed image: $IMAGE_DIGEST"
            cosign sign --yes $IMAGE_DIGEST || echo "Image signing completed or skipped"
          fi

      - name: Enable ECR scan on push and send to Security Hub
        run: |
          aws ecr put-image-scanning-configuration \
            --repository-name $ECR_REPOSITORY \
            --image-scanning-configuration scanOnPush=true || true
          
          echo "ECR scanning enabled. Results will be sent to AWS Security Hub if configured."

  security-approval:
    name: Security Approval Gate
    needs: [security-scan, build-and-push]
    if: always() && needs.build-and-push.result == 'success'
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
    steps:
      - name: Check security scan results
        run: |
          echo "Security scan status: ${{ needs.security-scan.outputs.security_status }}"
          echo "Critical vulnerabilities: ${{ needs.security-scan.outputs.critical_vulns }}"
          echo "High vulnerabilities: ${{ needs.security-scan.outputs.high_vulns }}"
          
          if [ "${{ needs.security-scan.outputs.security_status }}" = "failed" ]; then
            echo "WARNING: Security scan reported failures. Manual approval required."
          fi
          
          echo "Proceeding with deployment after security review..."

  deploy:
    name: Deploy to EC2 via SSM
    needs: [build-and-push, security-approval]
    if: always() && needs.build-and-push.result == 'success' && needs.security-approval.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    outputs:
      previous_image_tag: ${{ steps.get-current.outputs.previous_tag }}
      deployment_status: ${{ steps.deploy.outputs.status }}

    steps:
      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: github-actions-deploy
          aws-region: ${{ env.AWS_REGION }}
        continue-on-error: true
        id: oidc-auth

      - name: Configure AWS credentials (fallback to access keys)
        if: steps.oidc-auth.outcome == 'failure'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get EC2 instance ID and IP
        id: get-instance
        run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=client-timesheet-app" "Name=instance-state-name,Values=running" \
            --query 'Reservations[0].Instances[0].InstanceId' \
            --output text)
          INSTANCE_IP=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=client-timesheet-app" "Name=instance-state-name,Values=running" \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text)
          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "instance_ip=$INSTANCE_IP" >> $GITHUB_OUTPUT

      - name: Deploy via SSM Run Command
        id: deploy
        env:
          INSTANCE_ID: ${{ steps.get-instance.outputs.instance_id }}
        run: |
          # Send deployment command via SSM (no SSH needed)
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["sudo /opt/app/deploy.sh"]' \
            --timeout-seconds 300 \
            --query 'Command.CommandId' \
            --output text)
          
          echo "command_id=$COMMAND_ID" >> $GITHUB_OUTPUT
          echo "Deployment command sent. Command ID: $COMMAND_ID"
          
          # Wait for command to complete
          echo "Waiting for deployment to complete..."
          for i in {1..60}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query 'Status' \
              --output text 2>/dev/null || echo "Pending")
            
            if [ "$STATUS" = "Success" ]; then
              echo "Deployment completed successfully!"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'StandardOutputContent' \
                --output text
              break
            elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
              echo "Deployment failed with status: $STATUS"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'StandardErrorContent' \
                --output text
              exit 1
            fi
            
            echo "Status: $STATUS - waiting..."
            sleep 5
          done

      - name: Get current running image tag for rollback
        id: get-current
        env:
          INSTANCE_ID: ${{ steps.get-instance.outputs.instance_id }}
        run: |
          PREVIOUS_TAG=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["docker inspect --format={{.Config.Image}} $(docker ps -q) 2>/dev/null | grep -oP \":[^:]+$\" | tr -d \":\" || echo \"unknown\""]' \
            --query 'Command.CommandId' \
            --output text 2>/dev/null || echo "unknown")
          echo "previous_tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT
          echo "Previous image tag stored for potential rollback"

      - name: Health check
        id: health-check
        env:
          INSTANCE_IP: ${{ steps.get-instance.outputs.instance_ip }}
        run: |
          echo "Waiting for application to start..."
          sleep 10
          
          for i in {1..30}; do
            if curl -sf http://$INSTANCE_IP/health > /dev/null 2>&1; then
              echo "Application is healthy!"
              curl -s http://$INSTANCE_IP/health
              echo "health_status=success" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "Attempt $i: Waiting for application..."
            sleep 5
          done
          
          echo "Health check failed after 30 attempts"
          echo "health_status=failed" >> $GITHUB_OUTPUT
          exit 1

  rollback:
    name: Rollback on Failure
    needs: [deploy, build-and-push]
    if: failure() && needs.deploy.outputs.deployment_status == 'failed'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: github-actions-rollback
          aws-region: ${{ env.AWS_REGION }}
        continue-on-error: true
        id: oidc-auth

      - name: Configure AWS credentials (fallback to access keys)
        if: steps.oidc-auth.outcome == 'failure'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get EC2 instance ID
        id: get-instance
        run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=client-timesheet-app" "Name=instance-state-name,Values=running" \
            --query 'Reservations[0].Instances[0].InstanceId' \
            --output text)
          INSTANCE_IP=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=client-timesheet-app" "Name=instance-state-name,Values=running" \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text)
          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "instance_ip=$INSTANCE_IP" >> $GITHUB_OUTPUT

      - name: Rollback to previous version
        env:
          INSTANCE_ID: ${{ steps.get-instance.outputs.instance_id }}
          PREVIOUS_TAG: ${{ needs.deploy.outputs.previous_image_tag }}
        run: |
          echo "Initiating rollback to previous version..."
          
          if [ "$PREVIOUS_TAG" = "unknown" ] || [ -z "$PREVIOUS_TAG" ]; then
            echo "WARNING: Previous image tag unknown, attempting to use 'latest' tag from before this deployment"
            ROLLBACK_TAG="latest"
          else
            ROLLBACK_TAG="$PREVIOUS_TAG"
          fi
          
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[\"sudo /opt/app/deploy.sh rollback $ROLLBACK_TAG\"]" \
            --timeout-seconds 300 \
            --query 'Command.CommandId' \
            --output text)
          
          echo "Rollback command sent. Command ID: $COMMAND_ID"
          
          for i in {1..30}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query 'Status' \
              --output text 2>/dev/null || echo "Pending")
            
            if [ "$STATUS" = "Success" ]; then
              echo "Rollback completed successfully!"
              break
            elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
              echo "Rollback failed with status: $STATUS"
              exit 1
            fi
            
            echo "Status: $STATUS - waiting..."
            sleep 5
          done

      - name: Verify rollback health
        env:
          INSTANCE_IP: ${{ steps.get-instance.outputs.instance_ip }}
        run: |
          echo "Verifying rollback health..."
          sleep 10
          
          for i in {1..15}; do
            if curl -sf http://$INSTANCE_IP/health > /dev/null 2>&1; then
              echo "Rollback successful - application is healthy!"
              exit 0
            fi
            echo "Attempt $i: Waiting for application after rollback..."
            sleep 5
          done
          
          echo "WARNING: Application may still be unhealthy after rollback"
          exit 1

  runtime-security-monitoring:
    name: Runtime Security Monitoring Setup
    needs: [deploy]
    if: success()
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: github-actions-monitoring
          aws-region: ${{ env.AWS_REGION }}
        continue-on-error: true
        id: oidc-auth

      - name: Configure AWS credentials (fallback to access keys)
        if: steps.oidc-auth.outcome == 'failure'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Check ECR scan results and send to Security Hub
        run: |
          echo "Checking ECR scan results for deployed image..."
          
          aws ecr describe-image-scan-findings \
            --repository-name $ECR_REPOSITORY \
            --image-id imageTag=${{ needs.build-and-push.outputs.image_tag }} \
            --query 'imageScanFindings.findingSeverityCounts' \
            --output json 2>/dev/null || echo "ECR scan results not yet available"
          
          echo "Enabling Security Hub integration for ECR findings..."
          aws securityhub enable-import-findings-for-product \
            --product-arn "arn:aws:securityhub:${{ env.AWS_REGION }}::product/aws/ecr" 2>/dev/null || echo "Security Hub integration already enabled or not available"

      - name: Set up CVE monitoring alerts
        run: |
          echo "Setting up CloudWatch alarm for new CVEs..."
          
          aws cloudwatch put-metric-alarm \
            --alarm-name "ECR-Critical-CVE-Alert-$ECR_REPOSITORY" \
            --alarm-description "Alert when critical CVEs are found in ECR images" \
            --metric-name "CriticalVulnerabilityCount" \
            --namespace "AWS/ECR" \
            --statistic Maximum \
            --period 3600 \
            --threshold 1 \
            --comparison-operator GreaterThanOrEqualToThreshold \
            --evaluation-periods 1 \
            --dimensions Name=RepositoryName,Value=$ECR_REPOSITORY \
            --treat-missing-data notBreaching 2>/dev/null || echo "CloudWatch alarm setup skipped (may require additional permissions)"
          
          echo "Runtime security monitoring configured"
